"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./node_modules/@web3-react/metamask/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@web3-react/metamask/dist/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MetaMask = exports.NoMetaMaskError = void 0;\nconst types_1 = __webpack_require__(/*! @web3-react/types */ \"./node_modules/@web3-react/types/dist/index.js\");\nclass NoMetaMaskError extends Error {\n    constructor() {\n        super('MetaMask not installed');\n        this.name = NoMetaMaskError.name;\n        Object.setPrototypeOf(this, NoMetaMaskError.prototype);\n    }\n}\nexports.NoMetaMaskError = NoMetaMaskError;\nfunction parseChainId(chainId) {\n    return Number.parseInt(chainId, 16);\n}\nclass MetaMask extends types_1.Connector {\n    /**\n     * @param connectEagerly - A flag indicating whether connection should be initiated when the class is constructed.\n     * @param options - Options to pass to `@metamask/detect-provider`\n     */\n    constructor(actions, connectEagerly = false, options) {\n        super(actions);\n        if (connectEagerly && typeof window === 'undefined') {\n            throw new Error('connectEagerly = true is invalid for SSR, instead use the connectEagerly method in a useEffect');\n        }\n        this.options = options;\n        if (connectEagerly)\n            void this.connectEagerly();\n    }\n    isomorphicInitialize() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.eagerConnection)\n                return this.eagerConnection;\n            yield (this.eagerConnection = Promise.resolve().then(() => __importStar(__webpack_require__(/*! @metamask/detect-provider */ \"./node_modules/@metamask/detect-provider/dist/index.js\"))).then((m) => m.default(this.options))\n                .then((provider) => {\n                if (provider) {\n                    this.provider = provider;\n                    this.provider.on('connect', ({ chainId }) => {\n                        this.actions.update({ chainId: parseChainId(chainId) });\n                    });\n                    this.provider.on('disconnect', (error) => {\n                        this.actions.reportError(error);\n                    });\n                    this.provider.on('chainChanged', (chainId) => {\n                        this.actions.update({ chainId: parseChainId(chainId) });\n                    });\n                    this.provider.on('accountsChanged', (accounts) => {\n                        if (accounts.length === 0) {\n                            // handle this edge case by disconnecting\n                            this.actions.reportError(undefined);\n                        }\n                        else {\n                            this.actions.update({ accounts });\n                        }\n                    });\n                }\n            }));\n        });\n    }\n    /** {@inheritdoc Connector.connectEagerly} */\n    connectEagerly() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const cancelActivation = this.actions.startActivation();\n            yield this.isomorphicInitialize();\n            if (!this.provider)\n                return cancelActivation();\n            return Promise.all([\n                this.provider.request({ method: 'eth_chainId' }),\n                this.provider.request({ method: 'eth_accounts' }),\n            ])\n                .then(([chainId, accounts]) => {\n                if (accounts.length) {\n                    this.actions.update({ chainId: parseChainId(chainId), accounts });\n                }\n                else {\n                    throw new Error('No accounts returned');\n                }\n            })\n                .catch((error) => {\n                console.debug('Could not connect eagerly', error);\n                cancelActivation();\n            });\n        });\n    }\n    /**\n     * Initiates a connection.\n     *\n     * @param desiredChainIdOrChainParameters - If defined, indicates the desired chain to connect to. If the user is\n     * already connected to this chain, no additional steps will be taken. Otherwise, the user will be prompted to switch\n     * to the chain, if one of two conditions is met: either they already have it added in their extension, or the\n     * argument is of type AddEthereumChainParameter, in which case the user will be prompted to add the chain with the\n     * specified parameters first, before being prompted to switch.\n     */\n    activate(desiredChainIdOrChainParameters) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.actions.startActivation();\n            yield this.isomorphicInitialize();\n            if (!this.provider)\n                return this.actions.reportError(new NoMetaMaskError());\n            return Promise.all([\n                this.provider.request({ method: 'eth_chainId' }),\n                this.provider.request({ method: 'eth_requestAccounts' }),\n            ])\n                .then(([chainId, accounts]) => {\n                const receivedChainId = parseChainId(chainId);\n                const desiredChainId = typeof desiredChainIdOrChainParameters === 'number'\n                    ? desiredChainIdOrChainParameters\n                    : desiredChainIdOrChainParameters === null || desiredChainIdOrChainParameters === void 0 ? void 0 : desiredChainIdOrChainParameters.chainId;\n                // if there's no desired chain, or it's equal to the received, update\n                if (!desiredChainId || receivedChainId === desiredChainId)\n                    return this.actions.update({ chainId: receivedChainId, accounts });\n                const desiredChainIdHex = `0x${desiredChainId.toString(16)}`;\n                // if we're here, we can try to switch networks\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                return this.provider.request({\n                    method: 'wallet_switchEthereumChain',\n                    params: [{ chainId: desiredChainIdHex }],\n                })\n                    .catch((error) => {\n                    if (error.code === 4902 && typeof desiredChainIdOrChainParameters !== 'number') {\n                        // if we're here, we can try to add a new network\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        return this.provider.request({\n                            method: 'wallet_addEthereumChain',\n                            params: [Object.assign(Object.assign({}, desiredChainIdOrChainParameters), { chainId: desiredChainIdHex })],\n                        });\n                    }\n                    else {\n                        throw error;\n                    }\n                })\n                    .then(() => this.activate(desiredChainId));\n            })\n                .catch((error) => {\n                this.actions.reportError(error);\n            });\n        });\n    }\n}\nexports.MetaMask = MetaMask;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHdlYjMtcmVhY3QvbWV0YW1hc2svZGlzdC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxtQ0FBbUMsb0NBQW9DLGdCQUFnQjtBQUN2RixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyx1QkFBdUI7QUFDMUMsZ0JBQWdCLG1CQUFPLENBQUMseUVBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixtQkFBTyxDQUFDLHlGQUEyQjtBQUN2SDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RCw4Q0FBOEMsZ0NBQWdDO0FBQzlFLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsOENBQThDLGdDQUFnQztBQUM5RSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFVBQVU7QUFDNUQ7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsU0FBUyxzQ0FBc0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsdUJBQXVCO0FBQy9ELHdDQUF3Qyx3QkFBd0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDBDQUEwQztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsdUJBQXVCO0FBQy9ELHdDQUF3QywrQkFBK0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxvQ0FBb0M7QUFDckYsK0NBQStDLDRCQUE0QjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw0QkFBNEI7QUFDM0QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxzQ0FBc0MsNEJBQTRCO0FBQ3JJLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ad2ViMy1yZWFjdC9tZXRhbWFzay9kaXN0L2luZGV4LmpzP2UzYWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NZXRhTWFzayA9IGV4cG9ydHMuTm9NZXRhTWFza0Vycm9yID0gdm9pZCAwO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCJAd2ViMy1yZWFjdC90eXBlc1wiKTtcbmNsYXNzIE5vTWV0YU1hc2tFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ01ldGFNYXNrIG5vdCBpbnN0YWxsZWQnKTtcbiAgICAgICAgdGhpcy5uYW1lID0gTm9NZXRhTWFza0Vycm9yLm5hbWU7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBOb01ldGFNYXNrRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5leHBvcnRzLk5vTWV0YU1hc2tFcnJvciA9IE5vTWV0YU1hc2tFcnJvcjtcbmZ1bmN0aW9uIHBhcnNlQ2hhaW5JZChjaGFpbklkKSB7XG4gICAgcmV0dXJuIE51bWJlci5wYXJzZUludChjaGFpbklkLCAxNik7XG59XG5jbGFzcyBNZXRhTWFzayBleHRlbmRzIHR5cGVzXzEuQ29ubmVjdG9yIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY29ubmVjdEVhZ2VybHkgLSBBIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIGNvbm5lY3Rpb24gc2hvdWxkIGJlIGluaXRpYXRlZCB3aGVuIHRoZSBjbGFzcyBpcyBjb25zdHJ1Y3RlZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gcGFzcyB0byBgQG1ldGFtYXNrL2RldGVjdC1wcm92aWRlcmBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhY3Rpb25zLCBjb25uZWN0RWFnZXJseSA9IGZhbHNlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKGFjdGlvbnMpO1xuICAgICAgICBpZiAoY29ubmVjdEVhZ2VybHkgJiYgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29ubmVjdEVhZ2VybHkgPSB0cnVlIGlzIGludmFsaWQgZm9yIFNTUiwgaW5zdGVhZCB1c2UgdGhlIGNvbm5lY3RFYWdlcmx5IG1ldGhvZCBpbiBhIHVzZUVmZmVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIGlmIChjb25uZWN0RWFnZXJseSlcbiAgICAgICAgICAgIHZvaWQgdGhpcy5jb25uZWN0RWFnZXJseSgpO1xuICAgIH1cbiAgICBpc29tb3JwaGljSW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVhZ2VyQ29ubmVjdGlvbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWdlckNvbm5lY3Rpb247XG4gICAgICAgICAgICB5aWVsZCAodGhpcy5lYWdlckNvbm5lY3Rpb24gPSBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IF9faW1wb3J0U3RhcihyZXF1aXJlKCdAbWV0YW1hc2svZGV0ZWN0LXByb3ZpZGVyJykpKS50aGVuKChtKSA9PiBtLmRlZmF1bHQodGhpcy5vcHRpb25zKSlcbiAgICAgICAgICAgICAgICAudGhlbigocHJvdmlkZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyLm9uKCdjb25uZWN0JywgKHsgY2hhaW5JZCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGlvbnMudXBkYXRlKHsgY2hhaW5JZDogcGFyc2VDaGFpbklkKGNoYWluSWQpIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vbignZGlzY29ubmVjdCcsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zLnJlcG9ydEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIub24oJ2NoYWluQ2hhbmdlZCcsIChjaGFpbklkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGlvbnMudXBkYXRlKHsgY2hhaW5JZDogcGFyc2VDaGFpbklkKGNoYWluSWQpIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vbignYWNjb3VudHNDaGFuZ2VkJywgKGFjY291bnRzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWNjb3VudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIHRoaXMgZWRnZSBjYXNlIGJ5IGRpc2Nvbm5lY3RpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGlvbnMucmVwb3J0RXJyb3IodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy51cGRhdGUoeyBhY2NvdW50cyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIHtAaW5oZXJpdGRvYyBDb25uZWN0b3IuY29ubmVjdEVhZ2VybHl9ICovXG4gICAgY29ubmVjdEVhZ2VybHkoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjYW5jZWxBY3RpdmF0aW9uID0gdGhpcy5hY3Rpb25zLnN0YXJ0QWN0aXZhdGlvbigpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5pc29tb3JwaGljSW5pdGlhbGl6ZSgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnByb3ZpZGVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBjYW5jZWxBY3RpdmF0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIucmVxdWVzdCh7IG1ldGhvZDogJ2V0aF9jaGFpbklkJyB9KSxcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyLnJlcXVlc3QoeyBtZXRob2Q6ICdldGhfYWNjb3VudHMnIH0pLFxuICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAudGhlbigoW2NoYWluSWQsIGFjY291bnRzXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhY2NvdW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zLnVwZGF0ZSh7IGNoYWluSWQ6IHBhcnNlQ2hhaW5JZChjaGFpbklkKSwgYWNjb3VudHMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjY291bnRzIHJldHVybmVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnQ291bGQgbm90IGNvbm5lY3QgZWFnZXJseScsIGVycm9yKTtcbiAgICAgICAgICAgICAgICBjYW5jZWxBY3RpdmF0aW9uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYXRlcyBhIGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGVzaXJlZENoYWluSWRPckNoYWluUGFyYW1ldGVycyAtIElmIGRlZmluZWQsIGluZGljYXRlcyB0aGUgZGVzaXJlZCBjaGFpbiB0byBjb25uZWN0IHRvLiBJZiB0aGUgdXNlciBpc1xuICAgICAqIGFscmVhZHkgY29ubmVjdGVkIHRvIHRoaXMgY2hhaW4sIG5vIGFkZGl0aW9uYWwgc3RlcHMgd2lsbCBiZSB0YWtlbi4gT3RoZXJ3aXNlLCB0aGUgdXNlciB3aWxsIGJlIHByb21wdGVkIHRvIHN3aXRjaFxuICAgICAqIHRvIHRoZSBjaGFpbiwgaWYgb25lIG9mIHR3byBjb25kaXRpb25zIGlzIG1ldDogZWl0aGVyIHRoZXkgYWxyZWFkeSBoYXZlIGl0IGFkZGVkIGluIHRoZWlyIGV4dGVuc2lvbiwgb3IgdGhlXG4gICAgICogYXJndW1lbnQgaXMgb2YgdHlwZSBBZGRFdGhlcmV1bUNoYWluUGFyYW1ldGVyLCBpbiB3aGljaCBjYXNlIHRoZSB1c2VyIHdpbGwgYmUgcHJvbXB0ZWQgdG8gYWRkIHRoZSBjaGFpbiB3aXRoIHRoZVxuICAgICAqIHNwZWNpZmllZCBwYXJhbWV0ZXJzIGZpcnN0LCBiZWZvcmUgYmVpbmcgcHJvbXB0ZWQgdG8gc3dpdGNoLlxuICAgICAqL1xuICAgIGFjdGl2YXRlKGRlc2lyZWRDaGFpbklkT3JDaGFpblBhcmFtZXRlcnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5zdGFydEFjdGl2YXRpb24oKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuaXNvbW9ycGhpY0luaXRpYWxpemUoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5wcm92aWRlcilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3Rpb25zLnJlcG9ydEVycm9yKG5ldyBOb01ldGFNYXNrRXJyb3IoKSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIucmVxdWVzdCh7IG1ldGhvZDogJ2V0aF9jaGFpbklkJyB9KSxcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyLnJlcXVlc3QoeyBtZXRob2Q6ICdldGhfcmVxdWVzdEFjY291bnRzJyB9KSxcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKFtjaGFpbklkLCBhY2NvdW50c10pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWNlaXZlZENoYWluSWQgPSBwYXJzZUNoYWluSWQoY2hhaW5JZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVzaXJlZENoYWluSWQgPSB0eXBlb2YgZGVzaXJlZENoYWluSWRPckNoYWluUGFyYW1ldGVycyA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgPyBkZXNpcmVkQ2hhaW5JZE9yQ2hhaW5QYXJhbWV0ZXJzXG4gICAgICAgICAgICAgICAgICAgIDogZGVzaXJlZENoYWluSWRPckNoYWluUGFyYW1ldGVycyA9PT0gbnVsbCB8fCBkZXNpcmVkQ2hhaW5JZE9yQ2hhaW5QYXJhbWV0ZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZXNpcmVkQ2hhaW5JZE9yQ2hhaW5QYXJhbWV0ZXJzLmNoYWluSWQ7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUncyBubyBkZXNpcmVkIGNoYWluLCBvciBpdCdzIGVxdWFsIHRvIHRoZSByZWNlaXZlZCwgdXBkYXRlXG4gICAgICAgICAgICAgICAgaWYgKCFkZXNpcmVkQ2hhaW5JZCB8fCByZWNlaXZlZENoYWluSWQgPT09IGRlc2lyZWRDaGFpbklkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3Rpb25zLnVwZGF0ZSh7IGNoYWluSWQ6IHJlY2VpdmVkQ2hhaW5JZCwgYWNjb3VudHMgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVzaXJlZENoYWluSWRIZXggPSBgMHgke2Rlc2lyZWRDaGFpbklkLnRvU3RyaW5nKDE2KX1gO1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGhlcmUsIHdlIGNhbiB0cnkgdG8gc3dpdGNoIG5ldHdvcmtzXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnd2FsbGV0X3N3aXRjaEV0aGVyZXVtQ2hhaW4nLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFt7IGNoYWluSWQ6IGRlc2lyZWRDaGFpbklkSGV4IH1dLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IDQ5MDIgJiYgdHlwZW9mIGRlc2lyZWRDaGFpbklkT3JDaGFpblBhcmFtZXRlcnMgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSdyZSBoZXJlLCB3ZSBjYW4gdHJ5IHRvIGFkZCBhIG5ldyBuZXR3b3JrXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnd2FsbGV0X2FkZEV0aGVyZXVtQ2hhaW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogW09iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVzaXJlZENoYWluSWRPckNoYWluUGFyYW1ldGVycyksIHsgY2hhaW5JZDogZGVzaXJlZENoYWluSWRIZXggfSldLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuYWN0aXZhdGUoZGVzaXJlZENoYWluSWQpKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5yZXBvcnRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5NZXRhTWFzayA9IE1ldGFNYXNrO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@web3-react/metamask/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@web3-react/types/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@web3-react/types/dist/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Connector = void 0;\nclass Connector {\n    /**\n     * @param actions - Methods bound to a zustand store that tracks the state of the connector.\n     * Actions are used by the connector to report changes in connection status.\n     */\n    constructor(actions) {\n        this.actions = actions;\n    }\n    /**\n     * Initiate a disconnect.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    deactivate(...args) {\n        this.actions.reportError(undefined);\n    }\n}\nexports.Connector = Connector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHdlYjMtcmVhY3QvdHlwZXMvZGlzdC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B3ZWIzLXJlYWN0L3R5cGVzL2Rpc3QvaW5kZXguanM/NGFiZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29ubmVjdG9yID0gdm9pZCAwO1xuY2xhc3MgQ29ubmVjdG9yIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYWN0aW9ucyAtIE1ldGhvZHMgYm91bmQgdG8gYSB6dXN0YW5kIHN0b3JlIHRoYXQgdHJhY2tzIHRoZSBzdGF0ZSBvZiB0aGUgY29ubmVjdG9yLlxuICAgICAqIEFjdGlvbnMgYXJlIHVzZWQgYnkgdGhlIGNvbm5lY3RvciB0byByZXBvcnQgY2hhbmdlcyBpbiBjb25uZWN0aW9uIHN0YXR1cy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhY3Rpb25zKSB7XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IGFjdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYXRlIGEgZGlzY29ubmVjdC5cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgZGVhY3RpdmF0ZSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuYWN0aW9ucy5yZXBvcnRFcnJvcih1bmRlZmluZWQpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29ubmVjdG9yID0gQ29ubmVjdG9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@web3-react/types/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@web3-react/walletconnect/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@web3-react/walletconnect/dist/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WalletConnect = exports.URI_AVAILABLE = void 0;\nconst types_1 = __webpack_require__(/*! @web3-react/types */ \"./node_modules/@web3-react/types/dist/index.js\");\nconst eventemitter3_1 = __importDefault(__webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\"));\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/@web3-react/walletconnect/dist/utils.js\");\nexports.URI_AVAILABLE = 'URI_AVAILABLE';\nfunction parseChainId(chainId) {\n    return typeof chainId === 'string' ? Number.parseInt(chainId) : chainId;\n}\nclass WalletConnect extends types_1.Connector {\n    /**\n     * @param options - Options to pass to `@walletconnect/ethereum-provider`\n     * @param connectEagerly - A flag indicating whether connection should be initiated when the class is constructed.\n     */\n    constructor(actions, options, connectEagerly = false, treatModalCloseAsError = true) {\n        super(actions);\n        this.events = new eventemitter3_1.default();\n        this.disconnectListener = (error) => {\n            this.actions.reportError(error);\n        };\n        this.chainChangedListener = (chainId) => {\n            this.actions.update({ chainId: parseChainId(chainId) });\n        };\n        this.accountsChangedListener = (accounts) => {\n            this.actions.update({ accounts });\n        };\n        this.URIListener = (_, payload) => {\n            this.events.emit(exports.URI_AVAILABLE, payload.params[0]);\n        };\n        if (connectEagerly && typeof window === 'undefined') {\n            throw new Error('connectEagerly = true is invalid for SSR, instead use the connectEagerly method in a useEffect');\n        }\n        const { rpc } = options, rest = __rest(options, [\"rpc\"]);\n        this.rpc = Object.keys(rpc).reduce((accumulator, chainId) => {\n            const value = rpc[Number(chainId)];\n            accumulator[Number(chainId)] = Array.isArray(value) ? value : [value];\n            return accumulator;\n        }, {});\n        this.options = rest;\n        this.treatModalCloseAsError = treatModalCloseAsError;\n        if (connectEagerly)\n            void this.connectEagerly();\n    }\n    isomorphicInitialize(chainId = Number(Object.keys(this.rpc)[0])) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.eagerConnection)\n                return this.eagerConnection;\n            // because we can only use 1 url per chainId, we need to decide between multiple, where necessary\n            const rpc = Promise.all(Object.keys(this.rpc).map((chainId) => __awaiter(this, void 0, void 0, function* () { return [Number(chainId), yield (0, utils_1.getBestUrl)(this.rpc[Number(chainId)])]; }))).then((results) => results.reduce((accumulator, [chainId, url]) => {\n                accumulator[chainId] = url;\n                return accumulator;\n            }, {}));\n            yield (this.eagerConnection = Promise.resolve().then(() => __importStar(__webpack_require__(/*! @walletconnect/ethereum-provider */ \"./node_modules/@walletconnect/ethereum-provider/dist/esm/index.js\"))).then((m) => __awaiter(this, void 0, void 0, function* () {\n                this.provider = new m.default(Object.assign(Object.assign({}, this.options), { chainId, rpc: yield rpc }));\n                this.provider.on('disconnect', this.disconnectListener);\n                this.provider.on('chainChanged', this.chainChangedListener);\n                this.provider.on('accountsChanged', this.accountsChangedListener);\n                this.provider.connector.on('display_uri', this.URIListener);\n            })));\n        });\n    }\n    /** {@inheritdoc Connector.connectEagerly} */\n    connectEagerly() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const cancelActivation = this.actions.startActivation();\n            yield this.isomorphicInitialize();\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            if (this.provider.connected) {\n                try {\n                    // for walletconnect, we always use sequential instead of parallel fetches because otherwise\n                    // chainId defaults to 1 even if the connecting wallet isn't on mainnet\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    const accounts = yield this.provider.request({ method: 'eth_accounts' });\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    const chainId = parseChainId(yield this.provider.request({ method: 'eth_chainId' }));\n                    if (accounts.length) {\n                        this.actions.update({ chainId, accounts });\n                    }\n                    else {\n                        throw new Error('No accounts returned');\n                    }\n                }\n                catch (error) {\n                    console.debug('Could not connect eagerly', error);\n                    cancelActivation();\n                }\n            }\n            else {\n                cancelActivation();\n            }\n        });\n    }\n    /**\n     * Initiates a connection.\n     *\n     * @param desiredChainId - If defined, indicates the desired chain to connect to. If the user is\n     * already connected to this chain, no additional steps will be taken. Otherwise, the user will be prompted to switch\n     * to the chain, if their wallet supports it.\n     */\n    activate(desiredChainId) {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (desiredChainId && this.rpc[desiredChainId] === undefined) {\n                throw new Error(`no url(s) provided for desiredChainId ${desiredChainId}`);\n            }\n            // this early return clause catches some common cases if we're already connected\n            if ((_a = this.provider) === null || _a === void 0 ? void 0 : _a.connected) {\n                if (!desiredChainId || desiredChainId === this.provider.chainId)\n                    return;\n                const desiredChainIdHex = `0x${desiredChainId.toString(16)}`;\n                return this.provider\n                    .request({\n                    method: 'wallet_switchEthereumChain',\n                    params: [{ chainId: desiredChainIdHex }],\n                })\n                    .catch(() => void 0);\n            }\n            this.actions.startActivation();\n            // if we're trying to connect to a specific chain that we're not already initialized for, we have to re-initialize\n            if (desiredChainId && desiredChainId !== ((_b = this.provider) === null || _b === void 0 ? void 0 : _b.chainId))\n                yield this.deactivate();\n            yield this.isomorphicInitialize(desiredChainId);\n            try {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const accounts = yield this.provider.request({ method: 'eth_requestAccounts' });\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const chainId = parseChainId(yield this.provider.request({ method: 'eth_chainId' }));\n                if (!desiredChainId || desiredChainId === chainId) {\n                    return this.actions.update({ chainId, accounts });\n                }\n                // because e.g. metamask doesn't support wallet_switchEthereumChain, we have to report connections,\n                // even if the chainId isn't necessarily the desired one. this is ok because in e.g. rainbow,\n                // we won't report a connection to the wrong chain while the switch is pending because of the re-initialization\n                // logic above, which ensures first-time connections are to the correct chain in the first place\n                this.actions.update({ chainId, accounts });\n                // if we're here, we can try to switch networks, ignoring errors\n                const desiredChainIdHex = `0x${desiredChainId.toString(16)}`;\n                return (_c = this.provider) === null || _c === void 0 ? void 0 : _c.request({\n                    method: 'wallet_switchEthereumChain',\n                    params: [{ chainId: desiredChainIdHex }],\n                }).catch(() => void 0);\n            }\n            catch (error) {\n                // this condition is a bit of a hack :/\n                // if a user triggers the walletconnect modal, closes it, and then tries to connect again,\n                // the modal will not trigger. the logic below prevents this from happening\n                if (error.message === 'User closed modal') {\n                    yield this.deactivate(this.treatModalCloseAsError ? error : undefined);\n                }\n                else {\n                    this.actions.reportError(error);\n                }\n            }\n        });\n    }\n    /** {@inheritdoc Connector.deactivate} */\n    deactivate(error) {\n        var _a, _b, _c, _d, _e, _f;\n        return __awaiter(this, void 0, void 0, function* () {\n            (_a = this.provider) === null || _a === void 0 ? void 0 : _a.off('disconnect', this.disconnectListener);\n            (_b = this.provider) === null || _b === void 0 ? void 0 : _b.off('chainChanged', this.chainChangedListener);\n            (_c = this.provider) === null || _c === void 0 ? void 0 : _c.off('accountsChanged', this.accountsChangedListener);\n            (_e = (_d = this.provider) === null || _d === void 0 ? void 0 : _d.connector) === null || _e === void 0 ? void 0 : _e.off('display_uri', this.URIListener);\n            yield ((_f = this.provider) === null || _f === void 0 ? void 0 : _f.disconnect());\n            this.provider = undefined;\n            this.eagerConnection = undefined;\n            this.actions.reportError(error);\n        });\n    }\n}\nexports.WalletConnect = WalletConnect;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHdlYjMtcmVhY3Qvd2FsbGV0Y29ubmVjdC9kaXN0L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0MsZ0JBQWdCO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRyxxQkFBcUI7QUFDN0MsZ0JBQWdCLG1CQUFPLENBQUMseUVBQW1CO0FBQzNDLHdDQUF3QyxtQkFBTyxDQUFDLDREQUFlO0FBQy9ELGdCQUFnQixtQkFBTyxDQUFDLHVFQUFTO0FBQ2pDLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0NBQWdDO0FBQ2xFO0FBQ0E7QUFDQSxrQ0FBa0MsVUFBVTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSEFBMEgscUZBQXFGO0FBQy9NO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakIsb0ZBQW9GLG1CQUFPLENBQUMsMkdBQWtDO0FBQzlILDRFQUE0RSxtQkFBbUIseUJBQXlCO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLFNBQVMsc0NBQXNDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLHdCQUF3QjtBQUMzRjtBQUNBLCtFQUErRSx1QkFBdUI7QUFDdEc7QUFDQSw4Q0FBOEMsbUJBQW1CO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxlQUFlO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsNEJBQTRCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw0QkFBNEI7QUFDM0QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCwrQkFBK0I7QUFDOUY7QUFDQSwyRUFBMkUsdUJBQXVCO0FBQ2xHO0FBQ0EsaURBQWlELG1CQUFtQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG1CQUFtQjtBQUN6RDtBQUNBLCtDQUErQyw0QkFBNEI7QUFDM0U7QUFDQTtBQUNBLCtCQUErQiw0QkFBNEI7QUFDM0QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVMsa0NBQWtDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHFCQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHdlYjMtcmVhY3Qvd2FsbGV0Y29ubmVjdC9kaXN0L2luZGV4LmpzPzUxMzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XYWxsZXRDb25uZWN0ID0gZXhwb3J0cy5VUklfQVZBSUxBQkxFID0gdm9pZCAwO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCJAd2ViMy1yZWFjdC90eXBlc1wiKTtcbmNvbnN0IGV2ZW50ZW1pdHRlcjNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZXZlbnRlbWl0dGVyM1wiKSk7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5leHBvcnRzLlVSSV9BVkFJTEFCTEUgPSAnVVJJX0FWQUlMQUJMRSc7XG5mdW5jdGlvbiBwYXJzZUNoYWluSWQoY2hhaW5JZCkge1xuICAgIHJldHVybiB0eXBlb2YgY2hhaW5JZCA9PT0gJ3N0cmluZycgPyBOdW1iZXIucGFyc2VJbnQoY2hhaW5JZCkgOiBjaGFpbklkO1xufVxuY2xhc3MgV2FsbGV0Q29ubmVjdCBleHRlbmRzIHR5cGVzXzEuQ29ubmVjdG9yIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gcGFzcyB0byBgQHdhbGxldGNvbm5lY3QvZXRoZXJldW0tcHJvdmlkZXJgXG4gICAgICogQHBhcmFtIGNvbm5lY3RFYWdlcmx5IC0gQSBmbGFnIGluZGljYXRpbmcgd2hldGhlciBjb25uZWN0aW9uIHNob3VsZCBiZSBpbml0aWF0ZWQgd2hlbiB0aGUgY2xhc3MgaXMgY29uc3RydWN0ZWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYWN0aW9ucywgb3B0aW9ucywgY29ubmVjdEVhZ2VybHkgPSBmYWxzZSwgdHJlYXRNb2RhbENsb3NlQXNFcnJvciA9IHRydWUpIHtcbiAgICAgICAgc3VwZXIoYWN0aW9ucyk7XG4gICAgICAgIHRoaXMuZXZlbnRzID0gbmV3IGV2ZW50ZW1pdHRlcjNfMS5kZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdExpc3RlbmVyID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvbnMucmVwb3J0RXJyb3IoZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNoYWluQ2hhbmdlZExpc3RlbmVyID0gKGNoYWluSWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy51cGRhdGUoeyBjaGFpbklkOiBwYXJzZUNoYWluSWQoY2hhaW5JZCkgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWNjb3VudHNDaGFuZ2VkTGlzdGVuZXIgPSAoYWNjb3VudHMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy51cGRhdGUoeyBhY2NvdW50cyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5VUklMaXN0ZW5lciA9IChfLCBwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5lbWl0KGV4cG9ydHMuVVJJX0FWQUlMQUJMRSwgcGF5bG9hZC5wYXJhbXNbMF0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoY29ubmVjdEVhZ2VybHkgJiYgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29ubmVjdEVhZ2VybHkgPSB0cnVlIGlzIGludmFsaWQgZm9yIFNTUiwgaW5zdGVhZCB1c2UgdGhlIGNvbm5lY3RFYWdlcmx5IG1ldGhvZCBpbiBhIHVzZUVmZmVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcnBjIH0gPSBvcHRpb25zLCByZXN0ID0gX19yZXN0KG9wdGlvbnMsIFtcInJwY1wiXSk7XG4gICAgICAgIHRoaXMucnBjID0gT2JqZWN0LmtleXMocnBjKS5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBjaGFpbklkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJwY1tOdW1iZXIoY2hhaW5JZCldO1xuICAgICAgICAgICAgYWNjdW11bGF0b3JbTnVtYmVyKGNoYWluSWQpXSA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xuICAgICAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHJlc3Q7XG4gICAgICAgIHRoaXMudHJlYXRNb2RhbENsb3NlQXNFcnJvciA9IHRyZWF0TW9kYWxDbG9zZUFzRXJyb3I7XG4gICAgICAgIGlmIChjb25uZWN0RWFnZXJseSlcbiAgICAgICAgICAgIHZvaWQgdGhpcy5jb25uZWN0RWFnZXJseSgpO1xuICAgIH1cbiAgICBpc29tb3JwaGljSW5pdGlhbGl6ZShjaGFpbklkID0gTnVtYmVyKE9iamVjdC5rZXlzKHRoaXMucnBjKVswXSkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVhZ2VyQ29ubmVjdGlvbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWdlckNvbm5lY3Rpb247XG4gICAgICAgICAgICAvLyBiZWNhdXNlIHdlIGNhbiBvbmx5IHVzZSAxIHVybCBwZXIgY2hhaW5JZCwgd2UgbmVlZCB0byBkZWNpZGUgYmV0d2VlbiBtdWx0aXBsZSwgd2hlcmUgbmVjZXNzYXJ5XG4gICAgICAgICAgICBjb25zdCBycGMgPSBQcm9taXNlLmFsbChPYmplY3Qua2V5cyh0aGlzLnJwYykubWFwKChjaGFpbklkKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7IHJldHVybiBbTnVtYmVyKGNoYWluSWQpLCB5aWVsZCAoMCwgdXRpbHNfMS5nZXRCZXN0VXJsKSh0aGlzLnJwY1tOdW1iZXIoY2hhaW5JZCldKV07IH0pKSkudGhlbigocmVzdWx0cykgPT4gcmVzdWx0cy5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBbY2hhaW5JZCwgdXJsXSkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY3VtdWxhdG9yW2NoYWluSWRdID0gdXJsO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICAgICAgICAgIH0sIHt9KSk7XG4gICAgICAgICAgICB5aWVsZCAodGhpcy5lYWdlckNvbm5lY3Rpb24gPSBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IF9faW1wb3J0U3RhcihyZXF1aXJlKCdAd2FsbGV0Y29ubmVjdC9ldGhlcmV1bS1wcm92aWRlcicpKSkudGhlbigobSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIgPSBuZXcgbS5kZWZhdWx0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zKSwgeyBjaGFpbklkLCBycGM6IHlpZWxkIHJwYyB9KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vbignZGlzY29ubmVjdCcsIHRoaXMuZGlzY29ubmVjdExpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyLm9uKCdjaGFpbkNoYW5nZWQnLCB0aGlzLmNoYWluQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyLm9uKCdhY2NvdW50c0NoYW5nZWQnLCB0aGlzLmFjY291bnRzQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyLmNvbm5lY3Rvci5vbignZGlzcGxheV91cmknLCB0aGlzLlVSSUxpc3RlbmVyKTtcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKioge0Bpbmhlcml0ZG9jIENvbm5lY3Rvci5jb25uZWN0RWFnZXJseX0gKi9cbiAgICBjb25uZWN0RWFnZXJseSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbEFjdGl2YXRpb24gPSB0aGlzLmFjdGlvbnMuc3RhcnRBY3RpdmF0aW9uKCk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmlzb21vcnBoaWNJbml0aWFsaXplKCk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgaWYgKHRoaXMucHJvdmlkZXIuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHdhbGxldGNvbm5lY3QsIHdlIGFsd2F5cyB1c2Ugc2VxdWVudGlhbCBpbnN0ZWFkIG9mIHBhcmFsbGVsIGZldGNoZXMgYmVjYXVzZSBvdGhlcndpc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhaW5JZCBkZWZhdWx0cyB0byAxIGV2ZW4gaWYgdGhlIGNvbm5lY3Rpbmcgd2FsbGV0IGlzbid0IG9uIG1haW5uZXRcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWNjb3VudHMgPSB5aWVsZCB0aGlzLnByb3ZpZGVyLnJlcXVlc3QoeyBtZXRob2Q6ICdldGhfYWNjb3VudHMnIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFpbklkID0gcGFyc2VDaGFpbklkKHlpZWxkIHRoaXMucHJvdmlkZXIucmVxdWVzdCh7IG1ldGhvZDogJ2V0aF9jaGFpbklkJyB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY2NvdW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy51cGRhdGUoeyBjaGFpbklkLCBhY2NvdW50cyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYWNjb3VudHMgcmV0dXJuZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnQ291bGQgbm90IGNvbm5lY3QgZWFnZXJseScsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsQWN0aXZhdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbmNlbEFjdGl2YXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYXRlcyBhIGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGVzaXJlZENoYWluSWQgLSBJZiBkZWZpbmVkLCBpbmRpY2F0ZXMgdGhlIGRlc2lyZWQgY2hhaW4gdG8gY29ubmVjdCB0by4gSWYgdGhlIHVzZXIgaXNcbiAgICAgKiBhbHJlYWR5IGNvbm5lY3RlZCB0byB0aGlzIGNoYWluLCBubyBhZGRpdGlvbmFsIHN0ZXBzIHdpbGwgYmUgdGFrZW4uIE90aGVyd2lzZSwgdGhlIHVzZXIgd2lsbCBiZSBwcm9tcHRlZCB0byBzd2l0Y2hcbiAgICAgKiB0byB0aGUgY2hhaW4sIGlmIHRoZWlyIHdhbGxldCBzdXBwb3J0cyBpdC5cbiAgICAgKi9cbiAgICBhY3RpdmF0ZShkZXNpcmVkQ2hhaW5JZCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChkZXNpcmVkQ2hhaW5JZCAmJiB0aGlzLnJwY1tkZXNpcmVkQ2hhaW5JZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gdXJsKHMpIHByb3ZpZGVkIGZvciBkZXNpcmVkQ2hhaW5JZCAke2Rlc2lyZWRDaGFpbklkfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhpcyBlYXJseSByZXR1cm4gY2xhdXNlIGNhdGNoZXMgc29tZSBjb21tb24gY2FzZXMgaWYgd2UncmUgYWxyZWFkeSBjb25uZWN0ZWRcbiAgICAgICAgICAgIGlmICgoX2EgPSB0aGlzLnByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkZXNpcmVkQ2hhaW5JZCB8fCBkZXNpcmVkQ2hhaW5JZCA9PT0gdGhpcy5wcm92aWRlci5jaGFpbklkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY29uc3QgZGVzaXJlZENoYWluSWRIZXggPSBgMHgke2Rlc2lyZWRDaGFpbklkLnRvU3RyaW5nKDE2KX1gO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyXG4gICAgICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnd2FsbGV0X3N3aXRjaEV0aGVyZXVtQ2hhaW4nLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFt7IGNoYWluSWQ6IGRlc2lyZWRDaGFpbklkSGV4IH1dLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB2b2lkIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hY3Rpb25zLnN0YXJ0QWN0aXZhdGlvbigpO1xuICAgICAgICAgICAgLy8gaWYgd2UncmUgdHJ5aW5nIHRvIGNvbm5lY3QgdG8gYSBzcGVjaWZpYyBjaGFpbiB0aGF0IHdlJ3JlIG5vdCBhbHJlYWR5IGluaXRpYWxpemVkIGZvciwgd2UgaGF2ZSB0byByZS1pbml0aWFsaXplXG4gICAgICAgICAgICBpZiAoZGVzaXJlZENoYWluSWQgJiYgZGVzaXJlZENoYWluSWQgIT09ICgoX2IgPSB0aGlzLnByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2hhaW5JZCkpXG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5kZWFjdGl2YXRlKCk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmlzb21vcnBoaWNJbml0aWFsaXplKGRlc2lyZWRDaGFpbklkKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IHlpZWxkIHRoaXMucHJvdmlkZXIucmVxdWVzdCh7IG1ldGhvZDogJ2V0aF9yZXF1ZXN0QWNjb3VudHMnIH0pO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgY2hhaW5JZCA9IHBhcnNlQ2hhaW5JZCh5aWVsZCB0aGlzLnByb3ZpZGVyLnJlcXVlc3QoeyBtZXRob2Q6ICdldGhfY2hhaW5JZCcgfSkpO1xuICAgICAgICAgICAgICAgIGlmICghZGVzaXJlZENoYWluSWQgfHwgZGVzaXJlZENoYWluSWQgPT09IGNoYWluSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9ucy51cGRhdGUoeyBjaGFpbklkLCBhY2NvdW50cyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBlLmcuIG1ldGFtYXNrIGRvZXNuJ3Qgc3VwcG9ydCB3YWxsZXRfc3dpdGNoRXRoZXJldW1DaGFpbiwgd2UgaGF2ZSB0byByZXBvcnQgY29ubmVjdGlvbnMsXG4gICAgICAgICAgICAgICAgLy8gZXZlbiBpZiB0aGUgY2hhaW5JZCBpc24ndCBuZWNlc3NhcmlseSB0aGUgZGVzaXJlZCBvbmUuIHRoaXMgaXMgb2sgYmVjYXVzZSBpbiBlLmcuIHJhaW5ib3csXG4gICAgICAgICAgICAgICAgLy8gd2Ugd29uJ3QgcmVwb3J0IGEgY29ubmVjdGlvbiB0byB0aGUgd3JvbmcgY2hhaW4gd2hpbGUgdGhlIHN3aXRjaCBpcyBwZW5kaW5nIGJlY2F1c2Ugb2YgdGhlIHJlLWluaXRpYWxpemF0aW9uXG4gICAgICAgICAgICAgICAgLy8gbG9naWMgYWJvdmUsIHdoaWNoIGVuc3VyZXMgZmlyc3QtdGltZSBjb25uZWN0aW9ucyBhcmUgdG8gdGhlIGNvcnJlY3QgY2hhaW4gaW4gdGhlIGZpcnN0IHBsYWNlXG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zLnVwZGF0ZSh7IGNoYWluSWQsIGFjY291bnRzIH0pO1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGhlcmUsIHdlIGNhbiB0cnkgdG8gc3dpdGNoIG5ldHdvcmtzLCBpZ25vcmluZyBlcnJvcnNcbiAgICAgICAgICAgICAgICBjb25zdCBkZXNpcmVkQ2hhaW5JZEhleCA9IGAweCR7ZGVzaXJlZENoYWluSWQudG9TdHJpbmcoMTYpfWA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChfYyA9IHRoaXMucHJvdmlkZXIpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnd2FsbGV0X3N3aXRjaEV0aGVyZXVtQ2hhaW4nLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFt7IGNoYWluSWQ6IGRlc2lyZWRDaGFpbklkSGV4IH1dLFxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKCgpID0+IHZvaWQgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNvbmRpdGlvbiBpcyBhIGJpdCBvZiBhIGhhY2sgOi9cbiAgICAgICAgICAgICAgICAvLyBpZiBhIHVzZXIgdHJpZ2dlcnMgdGhlIHdhbGxldGNvbm5lY3QgbW9kYWwsIGNsb3NlcyBpdCwgYW5kIHRoZW4gdHJpZXMgdG8gY29ubmVjdCBhZ2FpbixcbiAgICAgICAgICAgICAgICAvLyB0aGUgbW9kYWwgd2lsbCBub3QgdHJpZ2dlci4gdGhlIGxvZ2ljIGJlbG93IHByZXZlbnRzIHRoaXMgZnJvbSBoYXBwZW5pbmdcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSA9PT0gJ1VzZXIgY2xvc2VkIG1vZGFsJykge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmRlYWN0aXZhdGUodGhpcy50cmVhdE1vZGFsQ2xvc2VBc0Vycm9yID8gZXJyb3IgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zLnJlcG9ydEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKioge0Bpbmhlcml0ZG9jIENvbm5lY3Rvci5kZWFjdGl2YXRlfSAqL1xuICAgIGRlYWN0aXZhdGUoZXJyb3IpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLnByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub2ZmKCdkaXNjb25uZWN0JywgdGhpcy5kaXNjb25uZWN0TGlzdGVuZXIpO1xuICAgICAgICAgICAgKF9iID0gdGhpcy5wcm92aWRlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm9mZignY2hhaW5DaGFuZ2VkJywgdGhpcy5jaGFpbkNoYW5nZWRMaXN0ZW5lcik7XG4gICAgICAgICAgICAoX2MgPSB0aGlzLnByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Mub2ZmKCdhY2NvdW50c0NoYW5nZWQnLCB0aGlzLmFjY291bnRzQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIChfZSA9IChfZCA9IHRoaXMucHJvdmlkZXIpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jb25uZWN0b3IpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5vZmYoJ2Rpc3BsYXlfdXJpJywgdGhpcy5VUklMaXN0ZW5lcik7XG4gICAgICAgICAgICB5aWVsZCAoKF9mID0gdGhpcy5wcm92aWRlcikgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmRpc2Nvbm5lY3QoKSk7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5lYWdlckNvbm5lY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmFjdGlvbnMucmVwb3J0RXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLldhbGxldENvbm5lY3QgPSBXYWxsZXRDb25uZWN0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@web3-react/walletconnect/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@web3-react/walletconnect/dist/utils.js":
/*!**************************************************************!*\
  !*** ./node_modules/@web3-react/walletconnect/dist/utils.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getBestUrl = void 0;\nfunction getBestUrl(urls) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // if we only have 1 url, it's the best!\n        if (urls.length === 1)\n            return urls[0];\n        const [HttpConnection, JsonRpcProvider] = yield Promise.all([\n            Promise.resolve().then(() => __importStar(__webpack_require__(/*! @walletconnect/jsonrpc-http-connection */ \"./node_modules/@walletconnect/jsonrpc-http-connection/dist/esm/index.js\"))).then(({ HttpConnection }) => HttpConnection),\n            Promise.resolve().then(() => __importStar(__webpack_require__(/*! @walletconnect/jsonrpc-provider */ \"./node_modules/@walletconnect/jsonrpc-provider/dist/esm/index.js\"))).then(({ JsonRpcProvider }) => JsonRpcProvider),\n        ]);\n        // the below returns the first url for which there's been a successful call, prioritized by index\n        return new Promise((resolve) => {\n            let resolved = false;\n            const successes = {};\n            urls.forEach((url, i) => {\n                const http = new JsonRpcProvider(new HttpConnection(url));\n                void http\n                    .request({ method: 'eth_chainId' })\n                    .then(() => true)\n                    .catch(() => false)\n                    .then((success) => {\n                    // if we already resolved, return\n                    if (resolved)\n                        return;\n                    // store the result of the call\n                    successes[i] = success;\n                    // if this is the last call and we haven't resolved yet - do so\n                    if (Object.keys(successes).length === urls.length) {\n                        const index = Object.keys(successes).findIndex((j) => successes[Number(j)]);\n                        // no need to set resolved to true, as this is the last promise\n                        return resolve(urls[index === -1 ? 0 : index]);\n                    }\n                    // otherwise, for each prospective index, check if we can resolve\n                    new Array(urls.length).fill(0).forEach((_, prospectiveIndex) => {\n                        // to resolve, we need to:\n                        // a) have successfully made a call\n                        // b) not be waiting on any other higher-index calls\n                        if (successes[prospectiveIndex] &&\n                            new Array(prospectiveIndex).fill(0).every((_, j) => successes[j] === false)) {\n                            resolved = true;\n                            resolve(urls[prospectiveIndex]);\n                        }\n                    });\n                });\n            });\n        });\n    });\n}\nexports.getBestUrl = getBestUrl;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHdlYjMtcmVhY3Qvd2FsbGV0Y29ubmVjdC9kaXN0L3V0aWxzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0MsZ0JBQWdCO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsbUJBQU8sQ0FBQyx1SEFBd0MsWUFBWSxnQkFBZ0I7QUFDbEksc0RBQXNELG1CQUFPLENBQUMseUdBQWlDLFlBQVksaUJBQWlCO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUJBQXVCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSxrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B3ZWIzLXJlYWN0L3dhbGxldGNvbm5lY3QvZGlzdC91dGlscy5qcz84ZWY4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0QmVzdFVybCA9IHZvaWQgMDtcbmZ1bmN0aW9uIGdldEJlc3RVcmwodXJscykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIC8vIGlmIHdlIG9ubHkgaGF2ZSAxIHVybCwgaXQncyB0aGUgYmVzdCFcbiAgICAgICAgaWYgKHVybHMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIHVybHNbMF07XG4gICAgICAgIGNvbnN0IFtIdHRwQ29ubmVjdGlvbiwgSnNvblJwY1Byb3ZpZGVyXSA9IHlpZWxkIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gX19pbXBvcnRTdGFyKHJlcXVpcmUoJ0B3YWxsZXRjb25uZWN0L2pzb25ycGMtaHR0cC1jb25uZWN0aW9uJykpKS50aGVuKCh7IEh0dHBDb25uZWN0aW9uIH0pID0+IEh0dHBDb25uZWN0aW9uKSxcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gX19pbXBvcnRTdGFyKHJlcXVpcmUoJ0B3YWxsZXRjb25uZWN0L2pzb25ycGMtcHJvdmlkZXInKSkpLnRoZW4oKHsgSnNvblJwY1Byb3ZpZGVyIH0pID0+IEpzb25ScGNQcm92aWRlciksXG4gICAgICAgIF0pO1xuICAgICAgICAvLyB0aGUgYmVsb3cgcmV0dXJucyB0aGUgZmlyc3QgdXJsIGZvciB3aGljaCB0aGVyZSdzIGJlZW4gYSBzdWNjZXNzZnVsIGNhbGwsIHByaW9yaXRpemVkIGJ5IGluZGV4XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlc29sdmVkID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzZXMgPSB7fTtcbiAgICAgICAgICAgIHVybHMuZm9yRWFjaCgodXJsLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaHR0cCA9IG5ldyBKc29uUnBjUHJvdmlkZXIobmV3IEh0dHBDb25uZWN0aW9uKHVybCkpO1xuICAgICAgICAgICAgICAgIHZvaWQgaHR0cFxuICAgICAgICAgICAgICAgICAgICAucmVxdWVzdCh7IG1ldGhvZDogJ2V0aF9jaGFpbklkJyB9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKCkgPT4gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChzdWNjZXNzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFscmVhZHkgcmVzb2x2ZWQsIHJldHVyblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIGNhbGxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc2VzW2ldID0gc3VjY2VzcztcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyB0aGUgbGFzdCBjYWxsIGFuZCB3ZSBoYXZlbid0IHJlc29sdmVkIHlldCAtIGRvIHNvXG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhzdWNjZXNzZXMpLmxlbmd0aCA9PT0gdXJscy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gT2JqZWN0LmtleXMoc3VjY2Vzc2VzKS5maW5kSW5kZXgoKGopID0+IHN1Y2Nlc3Nlc1tOdW1iZXIoaildKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gc2V0IHJlc29sdmVkIHRvIHRydWUsIGFzIHRoaXMgaXMgdGhlIGxhc3QgcHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodXJsc1tpbmRleCA9PT0gLTEgPyAwIDogaW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UsIGZvciBlYWNoIHByb3NwZWN0aXZlIGluZGV4LCBjaGVjayBpZiB3ZSBjYW4gcmVzb2x2ZVxuICAgICAgICAgICAgICAgICAgICBuZXcgQXJyYXkodXJscy5sZW5ndGgpLmZpbGwoMCkuZm9yRWFjaCgoXywgcHJvc3BlY3RpdmVJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gcmVzb2x2ZSwgd2UgbmVlZCB0bzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEpIGhhdmUgc3VjY2Vzc2Z1bGx5IG1hZGUgYSBjYWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBiKSBub3QgYmUgd2FpdGluZyBvbiBhbnkgb3RoZXIgaGlnaGVyLWluZGV4IGNhbGxzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VjY2Vzc2VzW3Byb3NwZWN0aXZlSW5kZXhdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEFycmF5KHByb3NwZWN0aXZlSW5kZXgpLmZpbGwoMCkuZXZlcnkoKF8sIGopID0+IHN1Y2Nlc3Nlc1tqXSA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodXJsc1twcm9zcGVjdGl2ZUluZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5nZXRCZXN0VXJsID0gZ2V0QmVzdFVybDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@web3-react/walletconnect/dist/utils.js\n");

/***/ })

});